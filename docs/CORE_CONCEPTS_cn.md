# 🧠 核心概念

理解这些基本概念将帮助您掌握 SentientResearchAgent 并构建强大的智能系统。

## 📋 目录

- [MECE 框架](#-the-mece-framework)
- [分层任务分解](#-分层任务分解)
- [执行流架构](#-执行流架构)
- [递归深度控制](#-递归深度控制)
- [阶段跟踪与透明度](#-阶段跟踪与透明度)
- [任务节点](#-任务节点)
- [节点类型](#-节点类型)
- [任务类型](#-任务类型)
- [任务状态生命周期](#-任务状态生命周期)
- [代理系统](#-代理系统)
- [上下文传播](#-上下文传播)
- [知识存储](#-知识存储)
- [执行策略](#-执行策略)

## 🎯 MECE 框架

SentientResearchAgent 的核心是 **MECE 原则**（相互独立，完全穷尽），它提供了一个通用框架，可以将任何任务分解为三个基本操作。

### 什么是 MECE？

MECE 是一种解决问题的原则，它确保完整覆盖而不重叠：
- **相互独立**：每种操作类型都是不同的——对于某个操作是思考、写入还是搜索，没有歧义。
- **完全穷尽**：这三种操作涵盖了所有可能的任务——您无需执行任何不属于这些类别之一的操作。

### 三个通用操作

#### 🤔 思考 - 推理与分析

任何在不创建新内容或检索外部数据的情况下处理信息的认知操作：
- **数据分析**：查找模式、趋势、见解
- **决策制定**：在选项之间进行选择，评估权衡
- **规划**：分解问题，制定策略
- **评估**：评估质量，检查正确性
- **问题解决**：寻找解决方案，调试问题

#### ✍️ 写入 - 内容生成与合成

任何创建新内容或合成现有信息的操作：
- **文档创建**：报告、文章、文档
- **代码生成**：编写程序、脚本、配置
- **创意内容**：故事、剧本、营销文案
- **合成**：将多个来源组合成连贯的输出
- **格式化**：结构化和呈现信息

#### 🔍 搜索 - 信息检索

任何从外部来源收集信息的操作：
- **网络研究**：查找在线信息
- **数据库查询**：检索结构化数据
- **API 调用**：从外部服务获取数据
- **文献综述**：学术或技术研究
- **数据收集**：收集原始信息

### 为什么 MECE 很重要

1. **普遍适用性**：任何任务都可以分解为这三种操作
2. **清晰的边界**：不会混淆使用哪种操作
3. **完全覆盖**：没有任何遗漏
4. **可伸缩的复杂性**：简单任务使用少量操作，复杂任务使用大量操作

### MECE 的实际应用

考虑构建市场分析报告：

```
目标：“为电动汽车创建全面的市场分析”

分解：
1. 搜索：收集市场数据和统计数据
2. 搜索：查找竞争对手信息
3. 搜索：收集监管信息
4. 思考：分析市场趋势
5. 思考：识别机遇和威胁
6. 写入：创建执行摘要
7. 写入：详细分析部分
8. 思考：审查并确保连贯性
9. 写入：带有建议的最终报告
```

每个操作都清晰地属于一种类型，它们共同完全实现了目标。

## 🔄 执行流架构

SentientResearchAgent 使用复杂的三向执行流，模仿自然的问题解决方式：

### 1. **自上而下的分解** ⬇️
任务从一般到具体：
```
“构建移动应用程序”（一般）
    ↓
“设计 UI” + “构建后端” + “编写测试”（具体）
    ↓
“创建登录屏幕” + “设计仪表板” + ...（更具体）
```

### 2. **自下而上的聚合** ⬆️
结果从具体到一般：
```
单个 UI 屏幕（具体）
    ↑
完整的 UI 设计（不那么具体）
    ↑
功能齐全的应用程序（一般）
```

### 3. **从左到右的依赖关系** ➡️
任务可以依赖同级任务来获取上下文：
```
“研究用户” → “设计功能” → “构建 MVP”
      （第一个）           （使用研究）    （两者都使用）
```


### 递归过程

1. **每个任务都从原子化器开始**
   - 评估任务复杂性
   - 决定：可以直接执行（执行）还是需要规划（规划）？

2. **如果是执行节点**：
   - 任务是原子性的（无法进一步分解）
   - 调用适当的执行代理
   - 返回结果

3. **如果是规划节点**：
   - 任务复杂且需要分解
   - 规划代理将其分解为子任务（思考、写入或搜索）
   - 每个子任务都经过自己的原子化器
   - 过程递归重复到任何深度

4. **横向依赖关系**（可选）：
   - 任务可以依赖同一级别的同级任务
   - 依赖任务等待前置任务完成
   - 存在依赖关系时，结果从左到右流动
   - 独立任务并行执行

5. **聚合器收集结果**：
   - 一旦所有子任务完成
   - 根据上下文智能地组合结果
   - 将合成结果返回给父级
   - 父级本身可能是更大树中的子任务

## 🎚️ 递归深度控制

SentientResearchAgent 最强大的功能之一是**可自定义的递归深度**，允许您控制任务分解的粒度。

*注意：目前，我们发现大多数用例在深度 **<= 3** 时效果良好*


### 控制深度

```python
# 快速任务的浅深度
agent = SentientAgent.create(max_depth=2)
quick_result = await agent.run("总结这篇文章")

# 综合分析的深深度
agent = SentientAgent.create(max_depth=5)
detailed_result = await agent.run("创建完整的商业计划")

# 自动深度（推荐）
agent = SentientAgent.create()  # 系统确定最佳深度
result = await agent.run("您的任务在这里")
```

### 深度指南

| 任务复杂性 | 推荐深度 | 用例 |
|----------------|-------------------|-----------|
| 简单 | 1 | 摘要、快速搜索、基本写作 |
| 中等 | 2-3 | 博客文章、报告、标准分析 |
| 复杂 | 3-4 | 深度报告、综合故事生成 |

## 🔍 阶段跟踪与透明度

**阶段跟踪** 是 SentientResearchAgent 的独特之处——对执行过程的每个步骤都具有完全的可见性。

### 什么是阶段跟踪？

阶段跟踪提供详细的日志：
- **输入**：每个代理收到的确切内容
- **处理**：代理如何解释和处理输入
- **输出**：代理生成的内容
- **上下文**：使用的周围信息
- **决策**：做出某些选择的原因

### 阶段跟踪的优点

1. **轻松调试**
   - 精确查看问题发生的位置
   - 了解为什么会产生某些输出
   - 识别瓶颈或效率低下

2. **优化机会**
   - 查找冗余操作
   - 识别慢速阶段
   - 优化提示和工作流程

3. **通过透明度建立信任**
   - 没有“黑匣子”之谜
   - 理解推理过程
   - 在每个步骤中验证正确性

4. **快速迭代**
   - 立即查看更改的效果
   - 快速测试不同的方法
   - 建立对代理的信心


## 🌳 分层任务分解

SentientResearchAgent 的核心原则是通过递归的原子化器-规划器-执行器架构进行**分层任务分解**。

### 概念

该框架通过递归过程模仿人类解决问题的方式：
1. **原子化器评估** - 此任务是原子性的还是需要规划？
2. **如果是原子性任务** - 使用适当的代理直接执行
3. **如果是复杂任务** - 规划并分解为子任务（思考、写入、搜索）
4. **递归处理** - 每个子任务都经过相同的评估
5. **聚合结果** - 通过聚合器自下而上地组合输出

### 原子化器流的可视化示例

```
“撰写一篇关于气候变化的研究论文”
             │
             ▼ [原子化器：太复杂 → 规划]
 ├── 研究当前气候数据
 │   │
 │   ▼ [原子化器：太复杂 → 规划]
 │   ├── 搜索温度趋势
 │   │   ▼ [原子化器：原子性 → 执行]
 │   ├── 搜索海平面数据
 │   │   ▼ [原子化器：原子性 → 执行]
 │   └── 搜索极端天气模式
 │       ▼ [原子化器：原子性 → 执行]
 │   ▲ [聚合器：组合搜索结果]
 │
 ├── 分析环境影响
 │   │
 │   ▼ [原子化器：太复杂 → 规划]
 │   ├── 对生态系统的影响
 │   │   ▼ [原子化器：原子性 → 执行]
 │   ├── 对人类社会的影响
 │   │   ▼ [原子化器：原子性 → 执行]
 │   └── 经济后果
 │       ▼ [原子化器：原子性 → 执行]
 │   ▲ [聚合器：合成分析]
 │
 └── 撰写和格式化论文
     │
     ▼ [原子化器：太复杂 → 规划]
     ├── 创建大纲
     │   ▼ [原子化器：原子性 → 执行]
     ├── 撰写部分
     │   ▼ [原子化器：原子性 → 执行]
     └── 添加引用
         ▼ [原子化器：原子性 → 执行]
     ▲ [聚合器：编译最终论文]
```

### 关键组件的实际应用

1. **原子化器** - 决定任务处理的看门人：
   - 评估复杂性
   - 路由到规划或执行
   - 确保适当的分解深度

2. **规划节点** - 分解器：
   - 将复杂任务分解为 MECE 子任务
   - 分配任务类型（思考、写入、搜索）
   - 定义依赖关系

3. **执行节点** - 工作者：
   - 处理原子性任务
   - 使用专业代理
   - 返回具体结果

4. **聚合器** - 合成器：
   - 收集所有子任务结果
   - 根据上下文智能地组合
   - 将统一输出返回给父级

### 优点

- **智能分解**：原子化器确保最佳任务分解
- **并行化**：独立子任务并发运行
- **专业化**：每个任务类型都有合适的代理
- **清晰度**：复杂目标变为可追溯的执行路径
- **灵活性**：递归深度适应任务复杂性

## 📦 任务节点

**任务节点** 是系统中的基本工作单元。

### 结构

```python
class TaskNode:
    # 标识
    task_id: str              # 唯一标识符（例如，“root.1.2”）
    goal: str                 # 此节点应完成的目标
    
    # 分类
    task_type: TaskType       # SEARCH、WRITE 或 THINK
    node_type: NodeType       # PLAN 或 EXECUTE
    
    # 层次结构
    layer: int                # 任务树中的深度（0 = 根）
    parent_node_id: str       # 父任务引用
    sub_graph_id: str         # 子任务图引用（PLAN 节点）
    
    # 状态
    status: TaskStatus        # 当前执行状态
    result: Any               # 任务输出
    error: str                # 如果失败，错误消息
    
    # 元数据
    timestamp_created: datetime
    timestamp_completed: datetime
    agent_name: str           # 处理此任务的代理
```

### 任务节点示例

```json
{
  "task_id": "root.1",
  "goal": "研究 2024 年可再生能源趋势",
  "task_type": "SEARCH",
  "node_type": "EXECUTE",
  "layer": 1,
  "parent_node_id": "root",
  "status": "DONE",
  "result": {
    "content": "太阳能容量增加了 73%...",
    "sources": ["IEA 2024 年报告", "彭博新能源财经"],
    "confidence": 0.92
  }
}
```

## 🎭 节点类型

### 规划节点

**目的**：将复杂任务分解为子任务

```python
# 规划节点示例
{
  "node_type": "PLAN",
  "goal": "分析市场趋势",
  "sub_graph_id": "subgraph_123",  # 指向子任务
  "planned_sub_task_ids": ["root.1", "root.2", "root.3"]
}
```

**特点**：
- 从不直接执行工作
- 创建和管理子任务
- 聚合子任务的结果
- 可以嵌套（计划中的计划）

### 执行节点

**目的**：执行实际工作

```python
# 执行节点示例
{
  "node_type": "EXECUTE",
  "goal": "搜索最新的 AI 突破",
  "agent_name": "SearchAgent",
  "result": "发现了 15 篇相关论文..."
}
```

**特点**：
- 任务树中的叶子节点
- 使用专业代理
- 产生具体结果
- 不能有子任务

## 🏷️ 任务类型

SentientResearchAgent 中的任务类型直接映射到 MECE 框架操作：

### 1. 搜索任务 🔍

**目的**：信息检索 - 从外部来源收集数据

```python
TaskType.SEARCH
```

**关键特征**：
- 始终从当前上下文外部检索信息
- 不创建新内容
- 不分析或做出决策
- 纯粹的信息收集

**示例**：
- 搜索最新信息
- 查询特定数据
- 调用外部服务的 API
- 文献综述和研究
- 事实核查和验证

**典型代理**：网络搜索器、数据库连接器、API 集成器、研究专家

### 2. 写入任务 ✍️

**目的**：内容生成 - 创建新信息或合成现有信息

```python
TaskType.WRITE
```

**关键特征**：
- 创建以前不存在的新内容
- 将信息合成为新形式
- 产生有形输出
- 不检索外部信息
- 不做分析决策

**示例**：
- 报告撰写和文档
- 代码生成和实现
- 创意内容（故事、剧本）
- 摘要和合成创建
- 格式化和呈现

**典型代理**：作家、编码员、合成器、格式化器、内容创作者

### 3. 思考任务 🤔

**目的**：分析和推理 - 处理信息以做出决策

```python
TaskType.THINK
```

**关键特征**：
- 分析现有信息
- 做出决策和评估
- 规划和制定策略
- 不创建新内容
- 不检索外部数据

**示例**：
- 数据分析和模式识别
- 战略规划和决策制定
- 问题解决和调试
- 质量评估和审查
- 任务分解和规划

**典型代理**：分析师、规划师、评估师、战略家、决策者


## 🤖 代理系统

代理是处理任务的工作者。每个代理都专注于特定的操作。

### 代理角色

#### 1. 原子化器代理

**目的**：确定任务是否需要分解

```python
Input: "撰写一篇关于 AI 的博客文章"
Output: {
  "is_atomic": False,  # 太复杂，需要规划
  "refined_goal": "撰写一篇关于 AI 发展趋势的综合博客文章"
}
```

#### 2. 规划代理

**目的**：分解复杂任务

```python
Input: "研究并比较云提供商"
Output: {
  "subtasks": [
    {"goal": "研究 AWS 功能和定价", "type": "SEARCH"},
    {"goal": "研究 Azure 功能和定价", "type": "SEARCH"},
    {"goal": "研究 GCP 功能和定价", "type": "SEARCH"},
    {"goal": "创建比较矩阵", "type": "THINK"},
    {"goal": "撰写推荐报告", "type": "WRITE"}
  ]
}
```

#### 3. 执行代理

**目的**：执行实际工作

```python
Input: "搜索量子计算应用"
Output: {
  "result": "发现了 5 个关键应用：密码学、药物发现...",
  "sources": ["Nature 2024", "MIT 研究"],
  "confidence": 0.88
}
```

#### 4. 聚合代理

**目的**：组合子任务的结果

```python
Input: [result1, result2, result3]
Output: {
  "summary": "综合分析显示...",
  "key_findings": ["发现 1", "发现 2"],
  "conclusion": "基于所有研究..."
}
```

## 🔗 上下文传播

上下文确保信息在任务之间智能流动。

### 上下文类型

#### 1. 血缘上下文

来自父任务和祖先任务的信息：
```python
{
  "overall_objective": "撰写投资报告",
  "parent_goal": "分析科技股",
  "constraints": ["关注 2024 年数据", "包括 ESG 因素"]
}
```

#### 2. 同级上下文

来自已完成同级任务的结果：
```python
{
  "sibling_results": [
    {"task": "研究公司 A", "result": "..."},
    {"task": "研究公司 B", "result": "..."}
  ]
}
```

#### 3. 全局上下文

系统范围信息：
```python
{
  "execution_id": "abc123",
  "timestamp": "2024-01-15",
  "user_preferences": {"style": "正式", "length": "详细"}
}
```

### 上下文流示例

```
根任务（上下文：用户请求）
    ↓（传递目标）
规划节点（上下文：目标 + 约束）
    ↓（传递规划上下文）
执行节点 1（上下文：规划 + 目标）
    →（共享结果）
执行节点 2（上下文：规划 + 目标 + 节点 1 结果）
    ↑（聚合所有）
聚合器（上下文：所有子结果 + 原始目标）
```

## 💾 知识存储

知识存储维护执行状态并启用上下文共享。

### 关键功能

#### 1. 结果存储

```python
knowledge_store.store_node_result(
    node_id="root.1",
    result={"content": "分析完成...", "score": 0.95}
)
```

#### 2. 上下文检索

```python
# 获取同一级别的结果
sibling_results = knowledge_store.get_sibling_results("root.2")

# 获取父上下文
parent_context = knowledge_store.get_parent_context("root.2.1")

# 获取所有相关上下文
context = knowledge_store.get_relevant_results_for_node(node)
```

#### 3. 血缘跟踪

```python
# 获取完整的执行路径
lineage = knowledge_store.get_node_lineage("root.1.2.3")
# 返回：["root", "root.1", "root.1.2", "root.1.2.3"]
```

### 存储优化

- **内存缓存** 用于快速访问
- **选择性持久化** 用于重要结果
- **上下文摘要** 用于管理大小
- **基于 TTL 的清理** 用于旧数据

## ⚡ 执行策略

### 1. 并行执行

独立任务同时运行：

```
        [任务 A] ──┐
根 ──→ [任务 B] ──┼──→ 聚合器
        [任务 C] ──┘
```

**配置**：
```yaml
execution:
  max_concurrent_nodes: 10
  enable_immediate_slot_fill: true
```

### 2. 顺序执行

有依赖关系的任务按顺序运行：

```
根 ──→ [任务 A] ──→ [任务 B] ──→ [任务 C] ──→ 结果
```

**用例**：当每个任务都依赖于前一个任务时

### 3. 混合策略

并行和顺序的组合：

```
        ┌─→ [研究 A] ─┐
根 ──→│                 ├──→ [分析] ──→ [报告]
        └─→ [研究 B] ─┘
```

## 🎯 综合应用

这些概念在实践中是如何运作的：

1. **用户提交目标** → 创建根任务节点
2. **原子化器检查复杂性** → 确定是规划还是执行
3. **规划器分解** → 创建子任务图
4. **调度器激活任务** → 基于依赖关系
5. **执行器处理** → 使用专业代理
6. **上下文流** → 在相关任务之间
7. **结果聚合** → 自下而上合成
8. **HITL 干预** → 在配置的检查点
9. **最终结果出现** → 来自分层处理

## 💡 最佳实践

### 1. 任务粒度

- 不要太宽泛：“解决世界饥饿问题” ❌
- 不要太狭窄：“输入字母 A” ❌
- 恰到好处：“研究非洲的粮食安全倡议” ✅

### 2. 代理选择

- 将代理与任务类型匹配
- 使用专业代理以获得更好的结果
- 为特定领域需求创建自定义代理

### 3. 上下文管理

- 保持上下文集中和相关
- 在层之间传递时进行摘要
- 保留关键信息

### 4. 错误处理

- 在每个级别计划失败情况
- 实施重试策略
- 提供有意义的错误消息