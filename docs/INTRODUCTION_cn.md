# 🚀 ROMA 简介

## 🌟 通用任务执行框架

**ROMA** 是一个**通用、分层的任务执行框架**，通过将复杂任务分解为基本原语，使您能够构建任何智能系统。目前，我们有以下基本原语：**思考 🤔、写入 ✍️ 和搜索 🔍**。

这不仅仅是另一个 AI 工具——它是一个**通用的支架，用于构建高性能代理**，这些代理可以使用 MECE（相互独立、完全穷尽）原则处理任何可分解的任务。从播客生成到市场分析，从故事写作到代码生成——只要你能想象，你就能构建它。

## 🎯 MECE 框架

SentientResearchAgent 的核心是 **MECE 原则**（相互独立、完全穷尽），它提供了一个通用框架，可以将任何任务分解为三个基本操作。

### 什么是 MECE？

MECE 是一种解决问题的原则，它确保完整覆盖而无重叠：
- **相互独立**：每种操作类型都是不同的——对于某个操作是思考、写入还是搜索，没有歧义
- **完全穷尽**：这三种操作涵盖了所有可能的任务——您无需执行任何不属于这些类别之一的操作

### 三个通用操作

#### 🤔 思考 - 推理与分析

任何在不创建新内容或检索外部数据的情况下处理信息的认知操作：
- **数据分析**：查找模式、趋势、见解
- **决策制定**：在选项之间进行选择，评估权衡
- **规划**：分解问题，制定策略
- **评估**：评估质量，检查正确性
- **问题解决**：寻找解决方案，调试问题

#### ✍️ 写入 - 内容生成与合成

任何创建新内容或合成现有信息的操作：
- **文档创建**：报告、文章、文档
- **代码生成**：编写程序、脚本、配置
- **创意内容**：故事、剧本、营销文案
- **合成**：将多个来源组合成连贯的输出
- **格式化**：结构化和呈现信息

#### 🔍 搜索 - 信息检索

任何从外部来源收集信息的操作：
- **网络研究**：查找在线信息
- **数据库查询**：检索结构化数据
- **API 调用**：从外部服务获取数据
- **文献综述**：学术或技术研究
- **数据收集**：收集原始信息

### 为什么 MECE 很重要

1. **普遍适用性**：任何任务都可以分解为这三种操作
2. **清晰的边界**：不会混淆使用哪种操作
3. **完全覆盖**：没有任何遗漏
4. **可伸缩的复杂性**：简单任务使用少量操作，复杂任务使用大量操作

### MECE 的实际应用

考虑构建市场分析报告：

```
目标：“为电动汽车创建全面的市场分析”

分解：
1. 搜索：收集市场数据和统计数据
2. 搜索：查找竞争对手信息
3. 搜索：收集监管信息
4. 思考：分析市场趋势
5. 思考：识别机遇和威胁
6. 写入：创建执行摘要
7. 写入：详细分析部分
8. 思考：审查并确保连贯性
9. 写入：带有建议的最终报告
```

每个操作都清晰地属于一种类型，并且它们共同完全实现了目标。

## 🔄 执行流架构

SentientResearchAgent 使用复杂的三向执行流，模仿自然的问题解决方式：

### 1. **自上而下的分解** ⬇️
任务从一般到具体：
```
“构建移动应用程序”（一般）
    ↓
“设计 UI” + “构建后端” + “编写测试”（具体）
    ↓
“创建登录屏幕” + “设计仪表板” + ...（更具体）
```

### 2. **自下而上的聚合** ⬆️
结果从具体到一般：
```
单个 UI 屏幕（具体）
    ↑
完整的 UI 设计（不那么具体）
    ↑
功能齐全的应用程序（一般）
```

### 3. **从左到右的依赖关系** ➡️
任务可以依赖同级任务来获取上下文：
```
“研究用户” → “设计功能” → “构建 MVP”
      （第一个）           （使用研究）    （两者都使用）
```


### 递归过程

1. **每个任务都从原子化器开始**
   - 评估任务复杂性
   - 决定：可以直接执行（执行）还是需要规划（规划）？

2. **如果是执行节点**：
   - 任务是原子性的（无法进一步分解）
   - 调用适当的执行代理
   - 返回结果

3. **如果是规划节点**：
   - 任务复杂且需要分解
   - 规划代理将其分解为子任务（思考、写入或搜索）
   - 每个子任务都经过自己的原子化器
   - 过程递归重复到任何深度

4. **横向依赖关系**（可选）：
   - 任务可以依赖同一级别的同级任务
   - 依赖任务等待前置任务完成
   - 存在依赖关系时，结果从左到右流动
   - 独立任务并行执行

5. **聚合器收集结果**：
   - 一旦所有子任务完成
   - 根据上下文智能地组合结果
   - 将合成结果返回给父级
   - 父级本身可能是更大树中的子任务

## 🎚️ 递归深度控制

SentientResearchAgent 最强大的功能之一是**可自定义的递归深度**，允许您控制任务分解的粒度。

*注意：目前，我们发现大多数用例在深度 **<= 3** 时效果良好*


### 控制深度

```python
# 快速任务的浅深度
agent = SentientAgent.create(max_depth=1)
quick_result = await agent.run("总结这篇文章")
```

### 深度指南

| 任务复杂性 | 推荐深度 | 用例 |
|----------------|-------------------|-----------|
| 简单 | 1 | 摘要、快速搜索、基本写作 |
| 中等 | 2-3 | 博客文章、报告、标准分析 |
| 复杂 | 3-4 | 深度报告、综合故事生成 |

## 🔍 阶段跟踪与透明度

**阶段跟踪** 是 ROMA 的独特之处——对执行过程的每个步骤都具有完全的可见性。

### 什么是阶段跟踪？

阶段跟踪提供详细的日志：
- **输入**：每个代理收到的确切内容
- **处理**：代理如何解释和处理输入
- **输出**：代理生成的内容
- **上下文**：使用的周围信息
- **决策**：做出某些选择的原因

### 阶段跟踪的优点

1. **轻松调试**
   - 精确查看问题发生的位置
   - 了解为什么会产生某些输出
   - 识别瓶颈或效率低下


2. **通过透明度建立信任**
   - 没有“黑匣子”之谜
   - 理解推理过程
   - 在每个步骤中验证正确性

3. **快速迭代**
   - 立即查看更改的效果
   - 快速测试不同的方法
   - 建立对代理的信心


## 🌳 分层任务分解

SentientResearchAgent 的核心原则是通过递归的原子化器-规划器-执行器架构进行**分层任务分解**。

### 概念

该框架通过递归过程模仿人类解决问题的方式：
1. **原子化器评估** - 此任务是原子性的还是需要规划？
2. **如果是原子性任务** - 使用适当的代理直接执行
3. **如果是复杂任务** - 规划并分解为子任务（思考、写入、搜索）
4. **递归处理** - 每个子任务都经过相同的评估
5. **聚合结果** - 通过聚合器自下而上地组合输出

### 原子化器流的可视化示例

```
“撰写一篇关于气候变化的研究论文”
             │
             ▼ [原子化器：太复杂 → 规划]
 ├── 研究当前气候数据
 │   │
 │   ▼ [原子化器：太复杂 → 规划]
 │   ├── 搜索温度趋势
 │   │   ▼ [原子化器：原子性 → 执行]
 │   ├── 搜索海平面数据
 │   │   ▼ [原子化器：原子性 → 执行]
 │   └── 搜索极端天气模式
 │       ▼ [原子化器：原子性 → 执行]
 │   ▲ [聚合器：组合搜索结果]
 │
 ├── 分析环境影响
 │   │
 │   ▼ [原子化器：太复杂 → 规划]
 │   ├── 对生态系统的影响
 │   │   ▼ [原子化器：原子性 → 执行]
 │   ├── 对人类社会的影响
 │   │   ▼ [原子化器：原子性 → 执行]
 │   └── 经济后果
 │       ▼ [原子化器：原子性 → 执行]
 │   ▲ [聚合器：合成分析]
 │
 └── 撰写和格式化论文
     │
     ▼ [原子化器：太复杂 → 规划]
     ├── 创建大纲
     │   ▼ [原子化器：原子性 → 执行]
     ├── 撰写部分
     │   ▼ [原子化器：原子性 → 执行]
     └── 添加引用
         ▼ [原子化器：原子性 → 执行]
     ▲ [聚合器：编译最终论文]
```

### 关键组件的实际应用

1. **原子化器** - 决定任务处理的看门人：
   - 评估复杂性
   - 路由到规划或执行
   - 确保适当的分解深度

2. **规划节点** - 分解器：
   - 将复杂任务分解为 MECE 子任务
   - 分配任务类型（思考、写入、搜索）
   - 定义依赖关系

3. **执行节点** - 工作者：
   - 处理原子性任务
   - 使用专业代理
   - 返回具体结果

4. **聚合器** - 合成器：
   - 收集所有子任务结果
   - 根据上下文智能地组合
   - 将统一输出返回给父级

### 优点

- **智能分解**：原子化器确保最佳任务分解
- **并行化**：独立子任务并发运行
- **专业化**：每个任务类型都有合适的代理
- **清晰度**：复杂目标变为可追溯的执行路径
- **灵活性**：递归深度适应任务复杂性


## 🎭 节点类型

### 规划节点

**目的**：将复杂任务分解为子任务

```python
# 规划节点示例
{
  "node_type": "PLAN",
  "goal": "分析市场趋势",
  "sub_graph_id": "subgraph_123",  # 指向子任务
  "planned_sub_task_ids": ["root.1", "root.2", "root.3"]
}
```

**特点**：
- 从不直接执行工作
- 创建和管理子任务
- 聚合子任务的结果
- 可以嵌套（计划中的计划）

### 执行节点

**目的**：执行实际工作

```python
# 执行节点示例
{
  "node_type": "EXECUTE",
  "goal": "搜索最新的 AI 突破",
  "agent_name": "SearchAgent",
  "result": "发现了 15 篇相关论文..."
}
```

**特点**：
- 任务树中的叶子节点
- 使用专业代理
- 产生具体结果
- 不能有子任务

## 🏷️ 任务类型

ROMA 中的任务类型直接映射到 MECE 框架操作：

### 1. 搜索任务 🔍

**目的**：信息检索 - 从外部来源收集数据

```python
TaskType.SEARCH
```

**关键特征**：
- 旨在从当前上下文外部检索信息
- 不旨在创建新内容
- 不旨在分析或做出决策

**示例**：
- 搜索最新信息
- 查询特定数据
- 调用外部服务的 API

**典型代理**：网络搜索器、数据库/知识库连接器、API 集成器

### 2. 写入任务 ✍️

**目的**：内容生成 - 创建新信息或合成现有信息

```python
TaskType.WRITE
```

**关键特征**：
- 创建以前不存在的新内容
- 将信息合成为新形式

**示例**：
- 报告撰写和文档
- 代码生成和实现
- 格式化和呈现

**典型代理**：作家、编码员、合成器、格式化器、内容创作者

### 3. 思考任务 🤔

**目的**：分析和推理 - 处理信息以做出决策

```python
TaskType.THINK
```

**关键特征**：
- 分析现有信息
- 做出决策和评估

**示例**：
- 数据分析和模式识别
- 战略规划和决策制定
- 数学推理

**典型代理**：分析师、推理器、一致性检查器


## 🤖 代理系统

代理是处理任务的工作者。每个代理都专注于特定的操作。

### 代理角色

#### 1. 原子化器代理

**目的**：确定任务是否需要分解

```python
Input: "撰写一篇关于 AI 的博客文章"
Output: {
  "is_atomic": False,  # 太复杂，需要规划
  "refined_goal": "撰写一篇关于 AI 发展趋势的综合博客文章"
}
```

#### 2. 规划代理

**目的**：分解复杂任务

```python
Input: "研究并比较云提供商"
Output: {
  "subtasks": [
    {"goal": "研究 AWS 功能和定价", "type": "SEARCH"},
    {"goal": "研究 Azure 功能和定价", "type": "SEARCH"},
    {"goal": "研究 GCP 功能和定价", "type": "SEARCH"},
    {"goal": "创建比较矩阵", "type": "THINK"},
    {"goal": "撰写推荐报告", "type": "WRITE"}
  ]
}
```

#### 3. 执行代理

**目的**：执行实际工作

```python
Input: "搜索量子计算应用"
Output: {
  "result": "发现了 5 个关键应用：密码学、药物发现...",
  "sources": ["Nature 2024", "MIT 研究"],
  "confidence": 0.88
}
```

#### 4. 聚合代理

**目的**：组合子任务的结果

```python
Input: [result1, result2, result3]
Output: {
  "summary": "综合分析显示...",
  "key_findings": ["发现 1", "发现 2"],
  "conclusion": "基于所有研究..."
}
```

## 🔗 上下文传播

上下文通过定义明确的传播策略确保信息在任务之间智能流动。

### 上下文传播策略

#### 1. 父到子传播

父目标将其上下文传递给子级，确保子级了解更广泛的目标：
```python
{
 "parent_goal": "撰写投资报告",
 "parent_constraints": ["关注 2024 年数据", "包括 ESG 因素"],
 "inherited_context": {
   "overall_objective": "季度投资组合审查",
   "style_guide": "正式"
 }
}
```

2. 同级到同级传播（基于依赖关系）
当一个节点依赖于先前的节点时，上下文在同级之间流动：

```python
{
  "dependency_context": {
    "depends_on": ["research_task_1", "research_task_2"],
    "sibling_results": [
      {"task_id": "research_task_1", "output": "公司 A 分析..."},
      {"task_id": "research_task_2", "output": "公司 B 分析..."}
    ]
  }
}
```
```text
根任务（上下文：用户请求）
    ↓（传播目标 + 约束）
规划节点（上下文：父上下文 + 规划约束）
    ↓（传播规划 + 父上下文）
执行节点 1（上下文：规划 + 父级认知）
    →（向依赖的同级提供结果）
执行节点 2（上下文：规划 + 父级认知 + 通过依赖关系获得的节点 1 结果）
    →（向依赖的同级提供结果）
执行节点 3（上下文：规划 + 父级认知 + 通过依赖关系获得的节点 1、2 结果）
    ↑（所有结果向上流动）
聚合器（上下文：所有子结果 + 原始父上下文）
```

**上下文类型**
<li>
血缘上下文：从父任务和祖先任务流出的信息</li>
<li>
依赖上下文：当前任务依赖的同级任务的结果</li>
<li>执行上下文：运行时信息和系统状态 </li>
<li>用户上下文：原始请求中的偏好和约束</li>


## ⚡ 执行策略

### 1. 并行执行

独立任务同时运行：

```
        [任务 A] ──┐
根 ──→ [任务 B] ──┼──→ 聚合器
        [任务 C] ──┘
```


### 2. 顺序执行

有依赖关系的任务按顺序运行：

```
根 ──→ [任务 A] ──→ [任务 B] ──→ [任务 C] ──→ 结果
```

**用例**：当每个任务都依赖于前一个任务时

### 3. 混合策略

并行和顺序的组合：

```
        ┌─→ [研究 A] ─┐
根 ──→│                 ├──→ [分析] ──→ [报告]
        └─→ [研究 B] ─┘
```

## 🎯 综合应用

这些概念在实践中是如何运作的：

1. **用户提交目标** → 创建根任务节点
2. **原子化器检查复杂性** → 确定是规划还是执行
3. **规划器分解** → 创建子任务图
4. **调度器激活任务** → 基于依赖关系
5. **执行器处理** → 使用专业代理
6. **上下文流** → 在相关任务之间
7. **结果聚合** → 自下而上合成
8. **最终结果出现** → 来自分层处理