from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional, Literal
from datetime import datetime
from enum import Enum # Import Enum for the isinstance check

# Using string literals for status, task_type, node_type to align with TaskNode enums
# but avoid circular dependency if TaskNode itself isn't fully defined when this is imported.
# Or, ensure TaskNode enums are in a common 'types.py' if preferred.

TaskStatusLiteral = Literal['PENDING', 'READY', 'RUNNING', 'PLAN_DONE', 'AGGREGATING', 'DONE', 'FAILED', 'NEEDS_REPLAN']
TaskTypeLiteral = Literal['WRITE', 'THINK', 'SEARCH', 'AGGREGATE', 'CODE_INTERPRET', 'IMAGE_GENERATION'] # Add all from TaskNode.TaskType
NodeTypeLiteral = Literal['PLAN', 'EXECUTE']


class TaskRecord(BaseModel):
    """Represents the historical record of a task in the Knowledge Store."""
    task_id: str
    goal: str
    task_type: TaskTypeLiteral
    node_type: Optional[NodeTypeLiteral] = None
    
    input_params_dict: Dict[str, Any] = Field(default_factory=dict)
    output_content: Optional[Any] = None
    output_type_description: Optional[str] = None # e.g., "text_report_section", "plan_output"
    output_summary: Optional[str] = None

    status: TaskStatusLiteral
    timestamp_created: datetime
    timestamp_updated: datetime
    timestamp_completed: Optional[datetime] = None
    
    parent_task_id: Optional[str] = None
    # child_task_ids refers to tasks *generated by this task* if it was a PLAN task
    child_task_ids_generated: List[str] = Field(default_factory=list)
    layer: Optional[int] = None
    error_message: Optional[str] = None

    class Config:
        use_enum_values = True # Keep this for serialization consistency if needed elsewhere


class KnowledgeStore(BaseModel):
    """A central repository for all task records."""
    records: Dict[str, TaskRecord] = Field(default_factory=dict)

    def add_or_update_record_from_node(self, node: Any): # Use Any to avoid circular dep with TaskNode initially
        """Creates or updates a TaskRecord from a TaskNode."""
        
        # --- MODIFIED SECTION START ---
        # Get the string value, checking if the attribute is an Enum or already a string
        task_type_val = node.task_type.value if isinstance(node.task_type, Enum) else node.task_type
        node_type_val = node.node_type.value if isinstance(node.node_type, Enum) and node.node_type else node.node_type
        status_val = node.status.value if isinstance(node.status, Enum) else node.status
        # --- MODIFIED SECTION END ---

        record = TaskRecord(
            task_id=node.task_id,
            goal=node.goal,
            task_type=task_type_val, # Use the derived string value
            node_type=node_type_val, # Use the derived string value (or None)
            input_params_dict=node.input_payload_dict or {},
            output_content=node.result,
            output_type_description=node.output_type_description,
            output_summary=node.output_summary,
            status=status_val, # Use the derived string value
            timestamp_created=node.timestamp_created,
            timestamp_updated=node.timestamp_updated,
            timestamp_completed=node.timestamp_completed,
            parent_task_id=node.parent_node_id,
            child_task_ids_generated=node.planned_sub_task_ids or [],
            layer=node.layer,
            error_message=node.error
        )
        self.records[record.task_id] = record
        print(f"KnowledgeStore: Added/Updated record for {node.task_id}")

    def get_record(self, task_id: str) -> Optional[TaskRecord]:
        return self.records.get(task_id)
