import asyncio
from loguru import logger
from sentientresearchagent.hierarchical_agent_framework.agents.base_adapter import LlmApiAdapter
from sentientresearchagent.hierarchical_agent_framework.node.task_node import TaskNode # Type hinting
from sentientresearchagent.hierarchical_agent_framework.context.agent_io_models import PlanOutput, AtomizerOutput, AgentTaskInput, ContextItem, CustomSearcherOutput, PlannerInput, PlanModifierInput, WebSearchResultsOutput # For type hinting
from typing import Any, List, Optional
from agno.agent import Agent as AgnoAgent # Renaming to avoid conflict if we define our own Agent interface
# It's good practice to also import the async version if available and distinct
# from agno.agent import AsyncAgent as AsyncAgnoAgent # Assuming such an import exists for type hinting
from .definitions.plan_modifier_agents import plan_modifier_agno_agent, PLAN_MODIFIER_AGENT_NAME # New import

# Assuming the AgnoAgent instances passed to these adapters during initialization
# are configured with the correct 'response_model' in their definitions.

class PlannerAdapter(LlmApiAdapter[PlannerInput, PlanOutput]):
    """Adapter specifically for Agno agents that perform planning and return PlanOutput."""

    async def process(self, node: TaskNode, agent_task_input: PlannerInput) -> PlanOutput:
        """
        Calls the underlying Agno planning agent and expects PlanOutput.

        Returns:
            PlanOutput: The structured plan generated by the agent.
        
        Raises:
            ValueError: If the Agno agent returns None content (which it shouldn't if PlanOutput is the response_model and parsing succeeds).
            TypeError: If the Agno agent does not return PlanOutput (should be caught by Agno if response_model is set).
        """
        # The base class process method handles calling the agent and getting response.content
        # It also handles the case where agno_agent.response_model is set and content is None (parsing failure).
        result_content: Optional[PlanOutput] = await super().process(node, agent_task_input)

        if result_content is None:
             logger.error(f"  PlannerAdapter Error: Agent '{self.agent_name}' returned None content for node {node.task_id}. Planning requires a valid PlanOutput.")
             # This case should ideally be caught by the base adapter if response_model=PlanOutput was set on the agno_agent
             # and agno failed to parse. If it reaches here as None, it means either response_model wasn't set
             # or the agent's arun itself returned None despite a response_model.
             raise ValueError(f"Planner agent '{self.agent_name}' returned None, which is not a valid PlanOutput for node {node.task_id}.")

        # Since the Agno agent should be defined with response_model=PlanOutput,
        # and the base adapter now raises if content is None with a response_model,
        # result_content here should be a PlanOutput instance.
        # The isinstance check is a final safeguard or if response_model wasn't strictly enforced.
        if not isinstance(result_content, PlanOutput):
            logger.error(f"  PlannerAdapter Error: Agent '{self.agent_name}' did not return PlanOutput for node {node.task_id}. Got: {type(result_content)}")
            raise TypeError(f"Planner agent '{self.agent_name}' was expected to return PlanOutput, but returned {type(result_content)}.")

        logger.success(f"  PlannerAdapter: Successfully received PlanOutput with {len(result_content.sub_tasks)} sub-tasks from agent '{self.agent_name}' for node {node.task_id}.")
        return result_content


class ExecutorAdapter(LlmApiAdapter[AgentTaskInput, Any]):
    """Adapter for Agno agents performing execution tasks (Write, Think, Search, etc.)."""
    
    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> Any:
        """
        Calls the underlying Agno execution agent. The result type depends on the agent.
        It could be a string, a specific Pydantic model (if response_model was set), etc.
        
        Returns:
            Any: The result content from the agent's execution.
        """
        # Base class process handles the call and returns response.content
        result_content: Any = await super().process(node, agent_task_input)
        
        # If the specific agno_agent for this executor has a response_model,
        # the base adapter would have raised an error if result_content was None after a parsing attempt.
        # If no response_model is set, None is a possible valid output from agno_agent.arun().
        if result_content is None:
             logger.warning(f"  ExecutorAdapter Warning: Agent '{self.agent_name}' returned None content for node {node.task_id}. This might be acceptable depending on the specific executor.")

        logger.info(f"  ExecutorAdapter: Received result of type '{type(result_content).__name__}' from agent '{self.agent_name}' for node {node.task_id}.")
        return result_content


class AtomizerAdapter(LlmApiAdapter[AgentTaskInput, AtomizerOutput]):
    """Adapter specifically for Agno agents performing atomicity checks."""

    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> AtomizerOutput:
        """
        Calls the underlying Agno atomizing agent and expects AtomizerOutput.

        Returns:
            AtomizerOutput: The structured result indicating atomicity and updated goal.
            
        Raises:
            ValueError: If the Agno agent returns None content.
            TypeError: If the Agno agent does not return AtomizerOutput.
        """
        result_content: Optional[AtomizerOutput] = await super().process(node, agent_task_input)

        if result_content is None:
             logger.error(f"  AtomizerAdapter Error: Agent '{self.agent_name}' returned None content for node {node.task_id}. Cannot determine atomicity.")
             raise ValueError(f"Atomizer agent '{self.agent_name}' returned None, which is not a valid AtomizerOutput for node {node.task_id}.")

        if not isinstance(result_content, AtomizerOutput):
            logger.error(f"  AtomizerAdapter Error: Agent '{self.agent_name}' did not return AtomizerOutput for node {node.task_id}. Got: {type(result_content)}")
            raise TypeError(f"Atomizer agent '{self.agent_name}' was expected to return AtomizerOutput, but returned {type(result_content)}.")
            
        logger.success(f"  AtomizerAdapter: Successfully received AtomizerOutput (is_atomic={result_content.is_atomic}) from agent '{self.agent_name}' for node {node.task_id}.")
        return result_content


class AggregatorAdapter(LlmApiAdapter[AgentTaskInput, str]): # Output is typically a string summary
    """Adapter for Agno agents performing aggregation of sub-task results."""

    def _format_context_for_prompt(self, context_items: List[ContextItem]) -> str:
        logger.debug(f"  AggregatorAdapter ({self.agent_name}): Formatting context with custom (less/no truncation) logic.")
        if not context_items:
            return "No relevant context (child task outputs) was provided."

        context_parts = ["Context from Child Tasks (Results):"]
        for i, item in enumerate(context_items):
            content_str = ""
            if isinstance(item.content, CustomSearcherOutput): # Example of specific handling
                content_str = item.content.output_text_with_citations # Get the richest text part
            elif isinstance(item.content, str):
                content_str = item.content
            elif hasattr(item.content, 'model_dump_json'): # For other Pydantic models
                try:
                    # Try to get a clean text representation if available
                    if hasattr(item.content, "text_content_for_llm"):
                         content_str = item.content.text_content_for_llm()
                    elif hasattr(item.content, "text"): # common attribute name
                         content_str = item.content.text
                    else: # Fallback to JSON
                         content_str = item.content.model_dump_json(indent=2) 
                except Exception:
                    content_str = str(item.content) # Fallback
            else:
                content_str = str(item.content)

            # For Aggregator, drastically increase or remove individual item truncation
            # MAX_LEN_AGGREGATOR_ITEM = 100000 # Or even higher, or remove truncation
            # if len(content_str) > MAX_LEN_AGGREGATOR_ITEM:
            #     logger.warning(f"    AggregatorAdapter: Context item from '{item.source_task_id}' for '{self.agent_name}' still truncated from {len(content_str)} to {MAX_LEN_AGGREGATOR_ITEM} chars.")
            #     content_str = content_str[:MAX_LEN_AGGREGATOR_ITEM] + f"... (truncated, original length {len(content_str)})"
            
            # No individual truncation, but be wary of total prompt size for the LLM
            
            context_parts.append(f"--- Child Task Result {i+1} (Source: '{item.source_task_id}', Goal: {item.source_task_goal[:100]}{'...' if len(item.source_task_goal)>100 else ''}) ---")
            context_parts.append(content_str)
            context_parts.append(f"--- End Child Task Result {i+1} ---")
        
        return "\n\n".join(context_parts)

    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> str:
        """
        Calls the underlying Agno aggregation agent, typically expecting a string result.

        Returns:
            str: The aggregated text content. An empty string if None was returned by agent.
        """
        # Base class process handles the call and gets response.content
        # Aggregator agents might not have a strict response_model beyond basic text,
        # so result_content could be None if the LLM returns nothing or if arun() fails mildly.
        result_content: Optional[Any] = await super().process(node, agent_task_input)

        if result_content is None:
            logger.warning(f"  AggregatorAdapter Warning: Agent '{self.agent_name}' returned None content for node {node.task_id}. Aggregation resulted in nothing. Returning empty string.")
            return "" # Return empty string instead of None to ensure string output type

        # Ensure the output is a string.
        result_str = str(result_content)
        logger.info(f"  AggregatorAdapter: Received aggregated result (length {len(result_str)}) from agent '{self.agent_name}' for node {node.task_id}.")
        return result_str


class PlanModifierAdapter(LlmApiAdapter[PlanModifierInput, PlanOutput]):
    """
    Adapter for the PlanModifierAgent, which revises an existing plan based on user feedback.
    """
    def __init__(self, agno_agent_instance: AgnoAgent, agent_name: str = "PlanModifierAdapter"):
        super().__init__(
            agno_agent_instance=agno_agent_instance,
            agent_name=agent_name
        )
        # self.agno_agent is now set by the parent LlmApiAdapter's __init__
        # Ensure the agent was correctly passed and initialized by the parent.
        if not self.agno_agent:
            logger.error(f"{self.agent_name}: Agno agent instance was not properly set by the parent initializer.")
            raise ValueError(f"Agno agent instance is None for {self.agent_name} after super().__init__.")
        
        logger.info(f"{self.agent_name} initialized with agent: {getattr(self.agno_agent, 'name', 'Unnamed Agno Agent')}")

    async def process(
        self,
        node: Optional[TaskNode], # Note: TaskNode might be None for some PlanModifier calls if not tied to a specific node state change.
        agent_task_input: PlanModifierInput, # This is now the InputType for this adapter
    ) -> PlanOutput:
        """
        Calls the underlying Agno plan modification agent and expects PlanOutput.
        Relies on the base LlmApiAdapter.process and an updated 
        _prepare_agno_run_arguments to handle PlanModifierInput.
        """
        result_content: Optional[PlanOutput] = await super().process(node, agent_task_input)

        if result_content is None:
            node_id_log = node.task_id if node else "N/A"
            logger.error(f"  PlanModifierAdapter Error: Agent '{self.agent_name}' returned None content for node {node_id_log}. Plan modification requires PlanOutput.")
            raise ValueError(f"PlanModifier agent '{self.agent_name}' returned None, which is not valid PlanOutput.")

        if not isinstance(result_content, PlanOutput):
            node_id_log = node.task_id if node else "N/A"
            logger.error(f"  PlanModifierAdapter Error: Agent '{self.agent_name}' for node {node_id_log} did not return PlanOutput. Got: {type(result_content)}")
            raise TypeError(f"PlanModifier agent '{self.agent_name}' was expected to return PlanOutput, but returned {type(result_content)}.")
        
        node_id_log = node.task_id if node else "N/A"
        logger.success(f"  PlanModifierAdapter: Successfully received revised PlanOutput with {len(result_content.sub_tasks)} sub-tasks from agent '{self.agent_name}' for node {node_id_log}.")
        return result_content


# Make sure to add PlanModifierInput to the Union type for AgentAdapterInput if you have one,
# or ensure your get_agent_adapter logic can handle retrieving this adapter.
# For example, if AgentAdapterInput was:
# AgentAdapterInput = Union[AgentTaskInput, PlannerInput, AggregatorInputContext]
# It might become:
# AgentAdapterInput = Union[AgentTaskInput, PlannerInput, AggregatorInputContext, PlanModifierInput]
# This is only relevant if you have a single `process_input_for_agent` type function.
# If `get_agent_adapter` returns specific adapter types whose `process` methods have specific
# input model types, this Union might not be in `adapters.py`.
