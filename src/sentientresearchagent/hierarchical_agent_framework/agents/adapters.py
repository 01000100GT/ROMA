from loguru import logger
from sentientresearchagent.hierarchical_agent_framework.agents.base_adapter import LlmApiAdapter
from sentientresearchagent.hierarchical_agent_framework.node.task_node import TaskNode # Type hinting
from sentientresearchagent.hierarchical_agent_framework.context.agent_io_models import PlanOutput, AtomizerOutput, AgentTaskInput, ContextItem, CustomSearcherOutput # For type hinting
from typing import Any, List
from agno.agent import Agent as AgnoAgent # Renaming to avoid conflict if we define our own Agent interface
# It's good practice to also import the async version if available and distinct
# from agno.agent import AsyncAgent as AsyncAgnoAgent # Assuming such an import exists for type hinting

# Assuming the AgnoAgent instances passed to these adapters during initialization
# are configured with the correct 'response_model' in their definitions.

class PlannerAdapter(LlmApiAdapter):
    """Adapter specifically for Agno agents that perform planning and return PlanOutput."""

    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> PlanOutput:
        """
        Calls the underlying Agno planning agent and expects PlanOutput.

        Returns:
            PlanOutput: The structured plan generated by the agent.
        
        Raises:
            TypeError: If the Agno agent does not return PlanOutput.
            ValueError: If the Agno agent returns None content.
        """
        # The base class process method handles calling the agent and getting response.content
        result_content = await super().process(node, agent_task_input)

        if result_content is None:
             logger.error(f"  PlannerAdapter Error: Agent '{self.agent_name}' returned None content for node {node.task_id}. Cannot proceed with planning.")
             # Raise an error because planning requires a valid PlanOutput
             raise ValueError(f"Planner agent '{self.agent_name}' returned None content for node {node.task_id}.")


        # Since the Agno agent was defined with response_model=PlanOutput,
        # response.content should already be a validated PlanOutput object.
        if not isinstance(result_content, PlanOutput):
            logger.error(f"  PlannerAdapter Error: Agent '{self.agent_name}' did not return PlanOutput for node {node.task_id}. Got: {type(result_content)}")
            # This indicates a mismatch between the adapter usage and the agent definition
            raise TypeError(f"Planner agent '{self.agent_name}' was expected to return PlanOutput, but returned {type(result_content)}.")

        logger.success(f"  PlannerAdapter: Successfully received PlanOutput with {len(result_content.sub_tasks)} sub-tasks from agent '{self.agent_name}' for node {node.task_id}.")
        return result_content


class ExecutorAdapter(LlmApiAdapter):
    """Adapter for Agno agents performing execution tasks (Write, Think, Search, etc.)."""
    
    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> Any:
        """
        Calls the underlying Agno execution agent. The result type depends on the agent.
        It could be a string, a specific Pydantic model (if response_model was set), etc.
        
        Returns:
            Any: The result content from the agent's execution.
        """
        # Base class process handles the call and returns response.content
        result_content = await super().process(node, agent_task_input)
        
        # No specific type check here, as executors can have varied outputs.
        # The NodeProcessor or subsequent tasks will handle the specific result type.
        # We might log a warning if content is None, but allow it to propagate.
        if result_content is None:
             logger.warning(f"  ExecutorAdapter Warning: Agent '{self.agent_name}' returned None content for node {node.task_id}.")

        logger.info(f"  ExecutorAdapter: Received result of type '{type(result_content).__name__}' from agent '{self.agent_name}' for node {node.task_id}.")
        return result_content


class AtomizerAdapter(LlmApiAdapter):
    """Adapter specifically for Agno agents performing atomicity checks."""

    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> AtomizerOutput:
        """
        Calls the underlying Agno atomizing agent and expects AtomizerOutput.

        Returns:
            AtomizerOutput: The structured result indicating atomicity and updated goal.
            
        Raises:
            TypeError: If the Agno agent does not return AtomizerOutput.
            ValueError: If the Agno agent returns None content.
        """
        result_content = await super().process(node, agent_task_input)

        if result_content is None:
             logger.error(f"  AtomizerAdapter Error: Agent '{self.agent_name}' returned None content for node {node.task_id}. Cannot determine atomicity.")
             raise ValueError(f"Atomizer agent '{self.agent_name}' returned None content for node {node.task_id}.")

        if not isinstance(result_content, AtomizerOutput):
            logger.error(f"  AtomizerAdapter Error: Agent '{self.agent_name}' did not return AtomizerOutput for node {node.task_id}. Got: {type(result_content)}")
            raise TypeError(f"Atomizer agent '{self.agent_name}' was expected to return AtomizerOutput, but returned {type(result_content)}.")
            
        logger.success(f"  AtomizerAdapter: Successfully received AtomizerOutput (is_atomic={result_content.is_atomic}) from agent '{self.agent_name}' for node {node.task_id}.")
        return result_content


class AggregatorAdapter(LlmApiAdapter):
    """Adapter for Agno agents performing aggregation of sub-task results."""

    def _format_context_for_prompt(self, context_items: List[ContextItem]) -> str:
        logger.debug(f"  AggregatorAdapter ({self.agent_name}): Formatting context with custom (less/no truncation) logic.")
        if not context_items:
            return "No relevant context (child task outputs) was provided."

        context_parts = ["Context from Child Tasks (Results):"]
        for i, item in enumerate(context_items):
            content_str = ""
            if isinstance(item.content, CustomSearcherOutput): # Example of specific handling
                content_str = item.content.output_text_with_citations # Get the richest text part
            elif isinstance(item.content, str):
                content_str = item.content
            elif hasattr(item.content, 'model_dump_json'): # For other Pydantic models
                try:
                    # Try to get a clean text representation if available
                    if hasattr(item.content, "text_content_for_llm"):
                         content_str = item.content.text_content_for_llm()
                    elif hasattr(item.content, "text"): # common attribute name
                         content_str = item.content.text
                    else: # Fallback to JSON
                         content_str = item.content.model_dump_json(indent=2) 
                except Exception:
                    content_str = str(item.content) # Fallback
            else:
                content_str = str(item.content)

            # For Aggregator, drastically increase or remove individual item truncation
            # MAX_LEN_AGGREGATOR_ITEM = 100000 # Or even higher, or remove truncation
            # if len(content_str) > MAX_LEN_AGGREGATOR_ITEM:
            #     logger.warning(f"    AggregatorAdapter: Context item from '{item.source_task_id}' for '{self.agent_name}' still truncated from {len(content_str)} to {MAX_LEN_AGGREGATOR_ITEM} chars.")
            #     content_str = content_str[:MAX_LEN_AGGREGATOR_ITEM] + f"... (truncated, original length {len(content_str)})"
            
            # No individual truncation, but be wary of total prompt size for the LLM
            
            context_parts.append(f"--- Child Task Result {i+1} (Source: '{item.source_task_id}', Goal: {item.source_task_goal[:100]}{'...' if len(item.source_task_goal)>100 else ''}) ---")
            context_parts.append(content_str)
            context_parts.append(f"--- End Child Task Result {i+1} ---")
        
        return "\\n\\n".join(context_parts)

    async def process(self, node: TaskNode, agent_task_input: AgentTaskInput) -> str:
        """
        Calls the underlying Agno aggregation agent, typically expecting a string result.

        Returns:
            str: The aggregated text content.
        """
        # Base class process handles the call and gets response.content
        result_content = await super().process(node, agent_task_input)

        # Aggregation usually results in text, but allow other types if needed.
        # Convert to string for consistency if it's not already.
        if result_content is None:
            logger.warning(f"  AggregatorAdapter Warning: Agent '{self.agent_name}' returned None content for node {node.task_id}. Aggregation resulted in nothing.")
            return "" # Return empty string instead of None

        result_str = str(result_content)
        logger.info(f"  AggregatorAdapter: Received aggregated result (length {len(result_str)}) from agent '{self.agent_name}' for node {node.task_id}.")
        return result_str
